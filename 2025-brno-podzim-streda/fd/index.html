<h1 id="soubory">Soubory
<a href="#soubory" class="header-link">#</a>
</h1>
<p>Co je to soubor?</p>
<p>Lehce naivní ale přesto užitečná definice je: soubor je něco,
z čeho můžeme číst a/nebo do čeho můžeme zapisovat.</p>
<p>Se soubory se dají dělat i další operace než jen čtení a zápis, ale v tomto
kurzu se jimi většinou nebudeme zabývat.</p>
<p>Pravděpodobně máš největší zkušenosti se soubory, které jsou uložené na disku
pod nějakým jménem.
Třeba následující příkaz zapisuje do souboru <code>vystup.txt</code>:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>ps<span class="w"> </span>-Af<span class="w"> </span>&gt;<span class="w"> </span>vystup.txt
</pre></div><p>Tento příkaz znamená: Bashi, spusť <code>ps -Af</code> a řekni mu aby psal do souboru
<code>vystup.txt</code>.
<code>ps</code> píše na svůj standardní výstup, což je soubor – v příkladu výše je to
soubor <code>vystup.txt</code>.</p>
<p>Kdybys výstup nepřesměrovala, uviděla bys ho v terminálu.
Pro program <code>ps</code> se nic nemění: pořád píše na svůj standardní výstup,
což je <em>soubor</em>.</p>
<p>Je to soubor, který reprezentuje terminál – něco, do čeho může proces zapisovat
(a co se pak objeví na obrazovce) a z čeho může číst (když uživatel něco zadá).
Obsah tohoto souboru není uložen na disku, ale přesto jde o soubor.</p>
<p>Podívej se na tenhle příkaz:</p>
<div class="highlight"><pre><code>$ ps -Af | grep -w ps
</code></pre></div><p>Příkaz <code>ps -Af</code> stále píše na svůj standardní výstup,
což je <em>soubor</em>.</p>
<p>V <em>tomhle</em> případě je to soubor, který reprezentuje „rouru“ – něco, do čeho
může jeden proces zapisovat a druhý to pak může číst.
Ani obsah roury není uložen na disku – „proudí“ přímo z jednoho procesu do
druhého – ale přesto jde o soubor.</p>
<p>Známe tedy už tři druhy souborů:</p>
<ul>
<li>normální souboru uložené na disku,</li>
<li>terminál,</li>
<li>rouru.</li>
</ul>
<h2 id="otevrene_soubory_procesu">Otevřené soubory procesu
<a href="#otevrene_soubory_procesu" class="header-link">#</a>
</h2>
<p>Každý proces si může otevírat další soubory - to už znáš z funkce <code>open</code>
v Pythonu.
Podíváme se, jak zjistit seznam takto používaných souborů.
Existuje na to program <code>lsof</code> (z angl. <em>list open files</em>).
Většinou se spouští s přepínačem <code>-p &lt;číslo procesu&gt;</code>, aby ukázal jen
otevřené soubory jednoho procesu.</p>
<p>Použijme PID Bashe, které se jednoduše zjišťuje – je v proměnné <code>$$</code>:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>lsof<span class="w"> </span>-p<span class="w"> </span><span class="nv">$$</span>
<span class="go">COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME</span>
<span class="go">bash    5236 user  cwd    DIR    8,1     4096 1310722 /home/user</span>
<span class="go">bash    5236 user  rtd    DIR    8,1     4096       2 /</span>
<span class="go">bash    5236 user  txt    REG    8,1  1113504  524393 /bin/bash</span>
<span class="go">bash    5236 user  mem    REG    8,1    47568 7344943 /lib/x86_64-linux-gnu/libnss_files-2.27.so</span>
<span class="go">bash    5236 user  mem    REG    8,1    26376 6032184 /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache</span>
<span class="gp gp-VirtualEnv">(...)</span>
<span class="go">bash    5236 user    0u   CHR  136,0      0t0       3 /dev/pts/0</span>
<span class="go">bash    5236 user    1u   CHR  136,0      0t0       3 /dev/pts/0</span>
<span class="go">bash    5236 user    2u   CHR  136,0      0t0       3 /dev/pts/0</span>
<span class="go">bash    5236 user  255u   CHR  136,0      0t0       3 /dev/pts/0</span>
</pre></div><p>Jak vidíš, je to poměrně velká tabulka.</p>
<ul>
<li><p><code>COMMAND</code> je jméno programu, který otvírá daný soubor
(bez <code>-p</code> vypisuje <code>lsof</code> soubory pro víc programů najednou).</p>
</li>
<li><p><code>PID</code> je číslo procesu, náš starý známý.</p>
</li>
<li><p><code>USER</code> je uživatel, jehož jménem proces běží.</p>
</li>
<li><p><code>FD</code> je zkratka pro <strong>deskriptor souboru</strong> (angl. <em>file descriptor</em>),
což je číslo otevřeného souboru. Toto číslo nás bude dnes nejvíc zajímat.</p>
<ul>
<li><code>cwd</code> je speciální hodnota pro aktuální adresář
(<em>current working directory</em>) – právě tahle hodnota se dá v Bashi změnit
pomocí <code>cd</code></li>
<li><code>rtd</code> je kořenový adresář (<em>root directory</em>) - mělo by to být <code>/</code></li>
<li><code>txt</code> je kód samotného programu. (Každý program musí být uložený někde
na disku. Když ho pustíš jako proces, systém soubor načte a začne provádět
příkazy v něm uložené.)</li>
<li><code>mem</code> jsou soubory načtené v paměti, většinou další součásti programu.</li>
<li><code>0</code> a dál jsou konečně normální otevřené soubory.
Písmenka označují mód, např.:<ul>
<li><code>1r</code> - otevřeno pro čtení (angl. <em>read</em>)</li>
<li><code>1w</code> - otevřeno pro zápis (angl. <em>write</em>)</li>
<li><code>1u</code> - otevřeno „univerzálně“, pro čtení i zápis</li>
</ul>
</li>
</ul>
</li>
<li><p><code>TYPE</code> může být např.</p>
<ul>
<li><code>DIR</code> - adresář</li>
<li><code>REG</code> - normální soubor</li>
<li><code>CHR</code> - speciální soubor, např. terminál</li>
</ul>
</li>
<li><p><code>DEVICE</code> - číslo zařízení (disku), na kterém soubor je</p>
</li>
<li><p><code>SIZE/OFF</code> - velikost / pozice v souboru</p>
</li>
<li><p><code>NODE</code> - číslo souboru (unikátní v rámci <code>DEVICE</code>)</p>
</li>
<li><p><code>NAME</code> - jméno souboru</p>
</li>
</ul>
<h2 id="terminal_jako_soubor">Terminál jako soubor
<a href="#terminal_jako_soubor" class="header-link">#</a>
</h2>
<p>Soubor, který má Bash otevřený jako <code>0u</code>, <code>1u</code> i <code>2u</code>, je za normálních
okolností terminál, ve kterém Bash běží.
Zjisti z výstupu výše, který to je.
V našem příkladu je to <code>/dev/pts/0</code>, u tebe může být jméno jiné.</p>
<p>Jak už víš, terminál je soubor, do kterého můžeš zapisovat.
Otevři si další okno terminálu a zadej následující příkaz. (Za <code>/dev/pts/0</code> doplň „svoje“ jméno terminálu):</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">echo</span><span class="w"> </span>abc<span class="w"> </span>&gt;<span class="w"> </span>/dev/pts/0
</pre></div><p>Všimni si, že se <code>abc</code> objeví ve druhém terminálovém okénku!</p>
<p>Když znáš jméno souboru a víš, jak se do něj dostat (znáš cestu), můžeš do něj zapisovat.
Soubor pro terminál není zas tolik zvláštní: jakmile znáš jméno, můžeš do něj zapisovat jako do jakéhokoli jiného souboru.</p>
<div class="admonition node"><p class="admonition-title">K čemu to je dobré?</p>
<p>Svého času takhle administrátoři posílali zprávy dalším lidem,
co zrovna pracovali na tom samém stroji.
Ale dnes se to už tolik nepoužívá.
Jen to ukazuje jak věci fungují – „všechno je soubor“.</p>
</div><h3 id="chybovy_vystup">Chybový výstup
<a href="#chybovy_vystup" class="header-link">#</a>
</h3>
<p>Tyto tři soubory, <code>0</code>, <code>1</code> a <code>2</code>, má každý proces otevřené.</p>
<p><code>0</code> je náš starý známý <em>standardní vstup</em>.
Když nepřesměrováváš, je to terminál: čte se to co napíšeš na klávesnici.
Ale může to být i jiný soubor – třeba následující <code>grep</code> má pod
číslem 0 otevřený soubor <code>soubory.py</code>:</p>
<div class="highlight"><pre><span></span><span class="go">grep print &lt; soubory.py</span>
</pre></div><p><code>1</code> je standardní výstup – místo, kam program píše informace,
které chce předat světu.</p>
<p><code>2</code> je ale nové: je to standardní <em>chybový</em> výstup
(angl. <em>standard error stream</em>, <em>stderr</em>), místo,
kam programy píší chybové hlášky.
Často to bývá stejný terminál jako <em>stdout</em>, ale přesměrovává se samostatně.</p>
<p>Zkus si třeba zkopírovat neexistující soubor pomocí <code>cp</code>.
Dostaneš chybovou hlášku:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>cp<span class="w"> </span>a<span class="w"> </span>b
<span class="go">cp: cannot stat a no such file or dir</span>
</pre></div><p>Když přesměruješ standardní výstup do souboru, chybová hláška se přesto objeví
v terminálu. Zkus:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>cp<span class="w"> </span>a<span class="w"> </span>b<span class="w"> </span>&gt;<span class="w"> </span>jiny.txt
<span class="go">cp: cannot stat a no such file or dir</span>
</pre></div><p>Zobáček <code>&gt;</code> přesměrovává pouze standardní výstup, zatímco chybový výstup
nechá nepřesměrovaný.</p>
<p>A k čemu je to užitečné?</p>
<p>Na standardní výstup programy většinou píšou výsledky své práce v nějakém
formátu, který se pak dá automaticky zpracovat.
Když nastane chyba, program ji ohlásí, ale ohlásí ji na jiném místě, než kam
vypíše výstup, aby nekazil další zpracování.</p>
<p>Když zadáš <code>ps -A | grep ps</code>, tak <code>grep</code> zpracovává výstup z příkazu <code>ps</code>:</p>
<div class="highlight"><pre><span></span><span class="gp">$  </span>ps<span class="w"> </span>-A<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>ps
<span class="go">    776 ?        00:00:00 psimon</span>
<span class="go">    840 ?        00:00:00 cupsd</span>
<span class="go">   5431 pts/1    00:00:00 ps</span>
</pre></div><p>Když ale uděláš chybu a vynecháš pomlčku před <code>A</code>,
tak se chyba vypíše na terminál a <code>grep</code> zpracuje jen prázdný soubor:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>ps<span class="w"> </span>-A<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>top
<span class="gp">[petr@fedora ~]$ </span>ps<span class="w"> </span>A<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>top
<span class="go">error: unsupported option (BSD syntax)</span>
<span class="gp gp-VirtualEnv">(...)</span>
</pre></div><h3 id="presmerovat_vsechno">Přesměrovat všechno
<a href="#presmerovat_vsechno" class="header-link">#</a>
</h3>
<p>Co kdybys ale přece jen chtěla přesměrovat ten druhý, chybový, výstup?
Existuje na to speciální operátor <code>2&gt;</code> - tedy přesměrování souboru číslo 2.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>$<span class="w"> </span>cp<span class="w"> </span>a<span class="w"> </span>b<span class="w"> </span><span class="m">2</span>&gt;<span class="w"> </span>jiny.txt
</pre></div><h4 id="presmerovani_obojiho">Přesměrování obojího
<a href="#presmerovani_obojiho" class="header-link">#</a>
</h4>
<p>Můžeš přesměrovat i oba výstupy:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>existuje.txt<span class="w"> </span>neexistuje.txt<span class="w"> </span>&gt;<span class="w"> </span>vystup.txt<span class="w"> </span><span class="m">2</span>&gt;<span class="w"> </span>chyby.txt
</pre></div><p>Když přesměrováváš do různých souborů, tak nezáleží na pořadí <code>&gt;</code> a <code>2&gt;</code>.</p>
<p>Když ale použiješ dvakrát stejný soubor (např. <code>&gt; jiny.txt 2&gt; jiny.txt</code>),
narazíš na problém: v souboru se většinou objeví jen jeden z výsledků.
Když je jeden soubor otevřený pro čtení dvakrát, a zapisuje se do obou zároveň, obvykle „vyhraje“ jen jeden.</p>
<p>Bash má na řešení této situace speciální operátor:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>existuje.txt<span class="w"> </span>neexistuje.txt<span class="w"> </span>&gt;<span class="w"> </span>jiny.txt<span class="w">  </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
<span class="gp">#                                             </span>^---<span class="w"> </span>chybový<span class="w"> </span>směruje<span class="w"> </span>tam,<span class="w"> </span>kam<span class="w"> </span>první
</pre></div><p>Kdyby v příkazu nebyl <code>&amp;</code>, výstup se přesměruje do souboru s názvem <code>1</code>.
<code>&amp;1</code> ale „odkazuje“ na soubor 1, tedy <code>jiny.txt</code>.</p>
<p>Tady už záleží v jakém pořadí se skládají příkazy, protože tohle fungovat nebude:</p>
<div class="highlight"><pre><code>#                                ,-------- 1. přesměruje stderr na stdout, tedy na terminál
#                                |   ,--- 2. přesměruje stdout do souboru
#                                ↓   ↓
$ls existuje.txt neexistuje.txt 2&gt;&amp;1 &gt; jiny.txt
</code></pre></div><p>Proto <em>stderr</em> půjde na terminál a <em>stdout</em> do souboru.</p>
<h3 id="presmerovani_vstupu">Přesměrování vstupu
<a href="#presmerovani_vstupu" class="header-link">#</a>
</h3>
<p>Pro úplnost si ukážeme i přesměrování standardního vstupu.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>grep<span class="w"> </span>print<span class="w"> </span>&lt;<span class="w"> </span>soubor.py
<span class="go">print(&quot;Hello&quot;)</span>
</pre></div><h2 id="zahozeni_vystupu">Zahození výstupu
<a href="#zahozeni_vystupu" class="header-link">#</a>
</h2>
<p>Zvláštní případ použití je přesměrování některého výstupu do speciálního
souboru, který si nic z toho co se do něj píše, neukládá.
Jmenuje se <code>/dev/null</code>.</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>existuje.txt<span class="w"> </span>neexistuje.txt<span class="w"> </span><span class="m">2</span>&gt;<span class="w"> </span>/dev/null
</pre></div><p>Celý chybový výstup se tak „vyhodí“.</p>
<div class="admonition note"><p><code>/dev/null</code> není ani normální soubor, ani terminál, ani roura.
Je to další druh speciálního souboru.</p>
</div><p>Jiný příklad - jsou programy, které píšou do terminálu spoustu výstupu.
Třeba <code>find</code>.
Pokud chceš vidět jen problémy, ale ne nalezené soubory, můžeš přesměrovat
standardní výstup do <code>/dev/null</code> a v terminálu uvidíš jen chybová hlášení
– tady o tom, že k některým souborům nemáš přístup:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>/var/cache<span class="w"> </span>&gt;<span class="w"> </span>/dev/null
<span class="go">find: … Permision denied</span>
</pre></div><p>Nebo naopak můžeš mít tolik souborů k nimž nemáš přístup,
že se ti ani nebude chtít o tom číst; chceš jen dostat ty ke kterým přístup máš.
Pak si do <code>/dev/null</code> přesměruješ chybový výstup:</p>
<div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>/var/cache<span class="w"> </span><span class="m">2</span>&gt;<span class="w"> </span>/dev/null
</pre></div>